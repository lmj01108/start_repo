# for_logic_circuit_review

/*
1. sequential circuit_flip-flop

  sequential circuit = combination circuit + memory element
  sequential circuit에 사용되는 memory element를 flip-flop이라고 한다.
  flip-flop : clock pulse를 사용하는 메모리


  Latches - clock 입력을 가지지 않는 기억소자, SR latch와 D latch 가 있음
  Flip-flop - clock 입력을 가져 이에 반응하여 출력의 상태를 바꾸는 기억소자
  Clock - 출력을 제어하는 입력(Ck)
  
  flip-flop 종류 - 상승 에지트리거 / 하강 에지트리거
      상승에지트리거 : 0에서 1로 바뀌는 구간 ex. 상승에지에서 변하는 소자이면 0에서 1로 바뀌는 상승에지에서만 입력값들이 
      하강이지트리거 : 1에서 0으로 바뀌는 구간
  
    1. SR latch - 입력 R, S와 출력 Q에 의해 다음 출력 Q(t+1)이 결정됨 S=R=1이면 Q=?이 되기 때문에 모순 발생
    2. D latch - SR latch 앞에 AND 게이트가 있고 입력 D와 SR 래치 동작을 제어해주는 G 입력으로 구성

*/

/*
# HDL - c언어가 기본
모듈 : 어떤 기능을 가지는 하나의 로직, "module"~"endmodule"안에 있어야함
모든 문장은 ; 으로 끝내고 "end~"로 시작하는 예약어에는 세미콜론 사용 안함

module 모듈이름 (포트목록);
    포트선언;
    레지스터 선언;
    와이어 선언;
    파라미터 선언;

    회로기능 표현;
        원시적인 연산자 또는
        assign문(조합회로표현)
        function문(조합회로표현)
        always문(순차회로표현)
        하위 모듈 호출 등.
endmodule (세미콜론 없음)

출처: https://ssmsig.tistory.com/53 [온라인 개인맞춤형 SIGMA!!]


input: 입력값을 받는 변수, input의 데이터 타입은 무조건 wire. reg가 될 수 없음
output: 출력값을 내는 변수
inout: 입출력.

wire: 실제로 회로를 물리적으로 연결하는 타입
reg: 데이터 저장 가능한 타입

*/

/*
EDA playground - testbench & design
full-adder - two half-adders & one or 

design code
module half_adder(x,y,s,c); //변수 순서 주의
  input x,y;
  output c,s;
  
  //s= x XOR y 내장함수는 변수 순서 정해져있음 - output이 먼저, 그 후에 input
  xor xor1(s,x,y);
  //c= x AND y
  and and1(c,x,y);
  
endmodule

module full_adder(x,y,z,c,s);
  input x,y,z;
  output c,s;
  wire c1, s1, c2; // 중간 & 결과 연산값
  
  // ha1, ha2, or1
  half_adder hal1(x, y, s1, c1);
  half_adder hal2(s1, z , s, c2); // 입출력 주의
  or or1(c, c2, c1);
endmodule


testbench code
module full_adder_tb;
  reg x,y,z;
  wire c,s;
  
  full_adder fa1(x,y,z,c,s);
  
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars(1);
    
    
    x=0;y=0;z=0; //간격 10
    #10 x=0;y=1;z=0;
    #10 x=1;y=0;z=0;
    #10 x=1;y=1;z=0;
    #10 x=0;y=0;z=1;
    #10 x=0;y=1;z=1;
    #10 x=1;y=0;z=1;
    #10 x=1;y=1;z=1;
    
    end  
  initial #200 $finish;
endmodule
*/
