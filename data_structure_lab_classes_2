# for recording the lab class

# 2022.5.10 binary_search_tree
""" Node Class: storing (key, value) """
class Node:
	def __init__(self, key=None, value=None, left=None, right=None):
		self.item = (key, value)
		self.left, self.right = left, right
	
	def key(self):
		return self.item[0]
	
	def value(self):
		return self.item[1]
	
	def set_value(self, value):
		self.item[1] = value


""" Binary Search Tree Class """
class BinarySearchTree:
	def __init__(self, root=None):
		self.root = root
	
	def search(self, key): # loop version ; key값 찾기
		root = self.root
		while root is not None:
			if key == root.key():
				break
			elif key < root.key(): #찾으려는 값이 root값 보다 작으면 왼쪽값을 root로 대입
				root = root.left
			elif key > root.key(): #찾으려는 값이 root값 보다 작으면 오른쪽 값을 root로 대입
				root = root.right
		
		return root
	
	""" returns node holding key and its parent"""
	def search_p(self, key): #key값과 해당 노드의 부모노드 값 찾기
		root, parent = self.root, None
		while root is not None: #root가 None이면 더이상 탐색할 노드가 없다.
			if key == root.key(): #key에 해당하는 node를 찾음
				break
			elif key < root.key(): #왼쪽 서브트리로 이동
				parent = root
				root = root.left
			elif key > root.key(): #오른쪽 서브트리로 이동
				parent = root
				root = root.right
		return root, parent
	
	def insert(self, key, value=None):
		node, p = self.search_p(key) # 존재하는지 확인
		if node is not None and k == node.key():
			node.set_value(value)
			return node
		
		new_node = Node(key, value)
		if p is None:
			self.root = new_node
		elif key < p.key():
			p.left = new_node
		else:
			p.right = new_node
		
		return node
	
	""" replace <node> with <rep_node> """ 
	# p: parent of <node>
	# rep_p: parent of <rep_node>
	def replace(self, node, rep_node, p, rep_p): 
		
		# A. REPLACE p-to-node link
		# case-1: node is root (p is None) root = rep_node
		if p is None: 
			self.root = rep_node
		# case-2: node is p.left / p.left = rep_node
		elif node == p.left : 
			p.left = rep_node
		# case-3: node is p.right / p.right = rep_node
		else: 
			p.right = rep_node
		
		# B. REPLACE node-to-child(s) link(s) IF <rep_node> exists
		# case-1: <rep_node> is <node>'s left child  --> Do nothing 이런경우는 있을 수 없음
		if node.left is None and node.right is None: #삭제할 노드의 자식노드가 없으면 대체할 값이 없음 rep_node = None
			rep_node = None
			
		else: # 삭제할 노드의 자식노드가 있는 경우의 케이스 3종류
			if rep_node == node.left:
				pass
		# case-2: <rep_node> is <node>'s right child --> replace the left link IF node.left exists
			elif rep_node == node.right and node.left is not None: # rep_node가 삭제될 노드의 오른쪽 자식 노드이면서 삭제할 노드의 왼쪽 자식도 존재하는 경우
				rep_node.left = node.left # 자식간의 link 변경
		# case-3: <rep_node> is not <node>'s child --> replace both left and right links
			elif node is not rep_p: #rep_node가 node의 자식노드가 아닐 경우
				rep_node.left = node.left # rep_node의 좌우 자식노드들 모두 node의 자식노드들로 변경
				rep_node.right = node.right
		# C. DELETE <rep_p> to <rep_node> link (already coded below)
		rep_p.left = None
			
	def find_min_p(self, root, p):
		while root.left is not None:
			p = root
			root = root.left
		return root, p
		
	def delete(self, key):
		node, p = self.search_p(key)
		if node is None:
			return node
		
		# number of children <= 1
		elif node.left is None or node.right is None:
			# determine the child (left or right?)
			child = node.left
			if node.right is not None: child = node.right
			# replace <node> with <child>
			self.replace(node, child, p, node)
		
		# number of children == 2
		else:
			# find minimum key from the right subtree
			right_min, right_min_p = self.find_min_p(node.right, node)
			# replace <node> with <right_min>
			self.replace(node, right_min, p, right_min_p)
			
		return node
	
	def preorder(self, root):
		if root is not None:
			print(root.key(), end=" ")
			self.preorder(root.left)
			self.preorder(root.right)
	
	def postorder(self, root):
		if root is not None:
			self.postorder(root.left)
			self.postorder(root.right)
			print(root.key(), end=" ")
	
	def inorder(self, root):
		if root is not None:
			self.inorder(root.left)
			print(root.key(), end=" ")
			self.inorder(root.right)
	
# 2022.5.18 Wed : No class	

# 2022.5.26 Wed - Gragh _asic_DFS

class Graph:
	def __init__(self, N=1000):
		self.N = N
		# Create 2D list M: M[i][j] = 1, if edge (i,j) exists
		self.M = [[0 for _ in range(N)] for _ in range(N)]
	
	def insert_edge(self, v1, v2):
		# this is an undirected graph
		self.M[v1][v2] = 1
		self.M[v2][v1] = 1
		
	
	def adjacent_vertices(self, v):
		# return the adjacent (or linked) vertices to v
		vs = []
		for j in range(self.N):
			if self.M[v][j] == 1:
				vd.append(j)
		return vs
	

class DFS:
	def __init__(self, G):
		# Graph Info
		self.G = G
		self.N = G.N
		
		# Vertex and Edge Labels
		# FOR LABELING, use EXACTLY these labels
		self.UNEXPLORED, self.VISITED = 'unxp', 'vstd' #vertex에 관한 라벨
		self.DISCOVERY, self.BACK = 'dscv', 'back' # edge에 관란 라벨
		
		# Initialize Vertex and Edge Labels 
		self.V_label = [self.UNEXPLORED for _ in range(N)]
		self.E_label = [[self.UNEXPLORED for _ in range(N)] for _ in range(N)]
		
		# Vertex Visiting Order during DFS
		self.visit_order = []
		
		# Run DFS
		for v in range(self.N):
			if self.V_label[v] == self.UNEXPLORED:
				self.dfs(v)
		

	def dfs(self, v):
		 # label v as VISITED
		 # and append v to visit_order list
		
		v_adj = self.G.adjacent_vertices(v)
		for w in v_adj:
			if self.M[v][w] and self.M[w][v] == self.UNEXPLORED: # if edge (v,w) and (w,v) is UNEXPLORED
				if # if w is UNEXPLORED:
				# label edge (v,w) as DISCOVERY
				# call dfs(w)
			# else:
				# label edge (v,w) as back
			
				
					
					
				
					
		
		pass
		

""" DO NOT CHANGE THE MAIN SCRIPT BELOW """
		
# Input: number of vertices
# and initialize Graph
N = int(input())
G = Graph(N)
	
# Input: edge_list
edges = input() # format: 1,2 0,1 2,3
edges = edges.split() # : ['1,2', '0,1', '2,3']
	
# Mark edges in G
for e in edges:
	u,v = e.split(",")
	u,v = int(u), int(v)
	G.insert_edge(u,v)

# Run DFS
D = DFS(G)
print('visit_order:', end=" ")
print(D.visit_order)
print('E_label:')

print("    ", end=" ")
for j in range(G.N):
	print('{:4d}'.format(j), end=" ")
print()

i =  0
for rows in D.E_label:
	print("{:4d}".format(i), end=" "); i += 1
	for x in rows:
		if x == D.UNEXPLORED: print("....", end=" ")
		else: print(x, end=" ")
	print()

	
	
	
