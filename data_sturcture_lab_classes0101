#2022.4.6
#Stack_01 : parantheses inspection
class Stack:
	def __init__(self):
		self.data = [] #initialize with anempty list
	def size(self):
		return len(self.data)
	def is_empty(self):
		return self.size() == 0 #True if empty, False otherwise
	def push(self, element):
		self.data.append(element)
	def pop(self):
		if self.is_empty():
			return "error"
		return self.data.pop()
	def top(self):
		if self.is_empty():
			return "error"
		return self.data[-1] # -1 : the last one
	
T = int(input())
for tc in range(1, T+1):
		sentence = input()
		l = len(sentence)
		lst = []
		for s in sentence:#( 이나 {이면 lst에 담음
			if s=='(' or s=='{':
				lst.append(s)#) 이나 }이 나오면 (나 { 전에 나왔는지 확인
			elif s==')' or s=='}':
				if len(lst)==0:
					False
					#적절하게 짝이 이루어졌는지 확인
					elif s==')' and lst.pop() =='{':
						False
					elif s=='}' and lst.pop() =='(':
						False
						#괄호가 모두 짝이 맞게 닫혔는지 확인
						if len(lst):
							result=0

		print('#{} {}'.format(tc, result))
	
	

#Stack_02 : infix-to-postfix
class Stack:
	def __init__(self):
		self.data = [] #initialize with anempty list	
	def size(self):
		return len(self.data)
	def is_empty(self):
		return self.size() == 0 #True if empty, False otherwise
	def push(self, element):
		self.data.append(element)
	def pop(self):
		if self.is_empty():
			return "error"
		return self.data.pop()
	def top(self):
		if self.is_empty():
			return "error"
		return self.data[-1] # -1 : the last one
	
#Infix-to-postfix #초기화
infix = input()
postfix = []
s = Stack()
	
precedence = {'+': 0, '-' : 0, '/' : 1, "*" : 1, '(' : 2}
	
for ch in infix : 
	#case 1: ch is operator or left bracket
	if ch in '+-/*(' : 
		while not s.is_empty() and precedence[ch] <= precedence[s.top()]:
			if s.top() == '(' :
				break
			op = s.pop()
			postfix.append(op)
		s.push(ch)
	elif ch == ')':# case2: reight bracket
		#pop until left bracket
		while not s.is_empty() and s.top() != '(':
			op = s.pop()
			postfix.append(op)
		s.pop() #pop the left bracket '('
		
	else: #operand
		#directly output to postfix
		postfix.append(ch)
		
while not s.is_empty():
				op = s.pop()
				postfix.append(op)
		
postfix = "".join(postfix)
print(postfix)
	

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

#2022.4.13 Wed
# sorting-compare

import random
import time

"""To check if the array is sorted"""
def is_sorted(A):
	if len(A)<2:
		return True
	
	for i in range(1, len(A)):
		if A[i-1] > A[i]:
			return False
	
	return True

"""sorting algorithms"""
def insertion_sort(A):
	for k in range(1, len(A)):
		cur = A[k]
		j=k
		while j>0 and A[j-1] > cur:
			A[j] = A[j-1]
			j -= 1
		A[j] = cur	
	
def merge(S1, S2, S):
	i=j=0
	while i+j < len(S):
		if j==len(S2) or (i < len(S1) and S1[i] < S2[j]):
			S[i+j] = S1[i]
			i += 1
		else: 
			S[i+j] = S2[j]
			j += 1
	
def merge_sort(S):
	n = len(S)
	if n < 2:
		return
	mid = n//2
	S1 = S[0:mid]
	S2 = S[mid:n]
	merge_sort(S1)
	merge_sort(S2)
	merge(S1, S2, S)

def quick_sort(S):
	n = len(S)
	if n < 2:
		return
	#divide
	pivot = S[0]
	L, E, G = [], [], []
	
	while len(S) > 0:
		x = S.pop()
		if x < pivot:
			L.append(x)
		elif x == pivot:
			E.append(x)
		else: 
			G.append(x)

	#conquer
	quick_sort(L)
	quick_sort(G)
	
	#combine L, E, G to S
	while len(L) > 0:
		S.append(L.pop(0))
	while len(E) > 0:
		S.append(E.pop(0))
	while len(G) > 0:
		S.append(G.pop(0))
	
n = 100 # change this value to compare different algorithms	
array = [random.randint(0, 999999999) for _ in range(n)]

array_insertion = array.copy()
start = time.perf_counter()
insertion_sort(array_insertion)
t_insertion = time.perf_counter() - start

array_merge = array.copy()
start = time.perf_counter()
merge_sort(array_merge)
t_merge = time.perf_counter() - start

array_quick = array.copy()
start = time.perf_counter()
quick_sort(array_quick)
t_quick = time.perf_counter() - start

if not is_sorted(array_insertion):
	print("insertion_sort: incorrect")
else:
	print("insertion_sort running time:", t_insertion)

if not is_sorted(array_merge):
	print("merge_sort:     incorrect")
else:
	print("merge_sort running time:", t_merge)

if not is_sorted(array_quick):
	print("quick_sort:     incorrect")
else:
	print("quick_sort running time:", t_quick)


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/


#2022.4.19 
#Linkedlist_lab
class Node:
	def __init__(self, item=None, link=None):
		self.item, self.link = item, link

class LinkedList:
		def __init__(self):	
			self.head = None
		def print_list(self):
			node = self.head
			print('h->', end="")
			while node is not None:
				print("{}->".format(node.item), end="")
				node = node.link
			print(None)
		def insert_node(self, p, new_node):
			if self.head is None:
				self.head = new_node
			elif p is None:
				new_node.link = self.head
				self.head = new_node
			else:
				new_node.link = p.link
				p.link = new_node
		def delete_node(self, p, removed):
			if removed == self.head:
				self.head = removed.link
			else:
				p.link = removed.link
			del removed
		def insert_first(self, item): # insert before head
			new_node = Node(item)
			self.insert_node(p=None, new_node=new_node) #이전 노드가 없어서 p는 None
		def insert_last(self, item): # insert after tail
			new_node = Node(item) # 새 노드를 가져옴
			p = self.head # 마지막 노드이기 때문에 p값이 있음
			while p is not None and p.link is not None: #p.link가 none이면 p가 tail
				p = p.link
			self.insert_node(p=p, new_node = new_node)#	
		def search(self, item): # returns the node holding item
			node = self.head
			while node is not None:
				if node.item == item:
					return node
				node = node.link
			return None
		def search_prev(self, item): # returns the node holding item and the previous node
			p = None
			node = self.head
			while node is not None:
				if node.item == item :
					return node, p
				p = node
				node = node.link
			return None, p	
		def delete(self, item):
			removed ,p= self.search_prev(item) #search_prev으로 node찾기
			if removed is None: # removed는 삭제하려는 값임, 만약 이 값이 없다면
				print("Item not found")
				return
			self.delete_node(p=p, removed = removed) #delete_node로 삭제
		def reverse(self):
			p = None
			node = self.head
			while node is not None:
				new_node = node.link
				node.link = p
				p = node
				node = new_node
			self.head = p	

L = LinkedList()
while True:
	cmd = input()
	if cmd == "exit":
		break
	elif cmd == "print":
		L.print_list()
	elif cmd == "reverse":
			L.reverse()
	else:
		cmd, param = cmd.split() #cmd를 콜하기 위한 코드
		if cmd == "ins_first":
			L.insert_first(int(param))
		elif cmd == "ins_last":
			L.insert_last(int(param))
		elif cmd == "find":
			node = L.search(int(param))
			if node is None: print('Item Not Found')
			else: print("{} Found".format(node.item))
		elif cmd == "del":
			L.delete(int(param))
		

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

# 2022.4.21 Thu
# circular queue
class queue:
	DEFAULT_CAPACITY = 0
	
	def __init__(self):
		self._data = [None] * queue.DEFAULT_CAPACITY
		self._size = 0
		self._front = 0
		
	def __len__(self):
		return self._size
	
	def is_empty(self):
		return self._size == 0
	
	def first(self):
		if self.is_empty():
			raise Empty('Queue is empty')
		return self._data[self._front]
	
	def dequeue(self):
		if self.is_empty():
			raise Empty('Queue is empty')
		answer = self._data[self._front]
		self._data[self._front] = None
		self._front = (self._front + 1)% len(self._data)
		self._size -= 1
		return answer
	
	def enqueue(self, e):
		if self._size == len(self._data):
			self._resize(2*len(self.data))
		avail = (self._front + self._size) % len(self._data)
		self._data[avail] = e 
		self._size += 1
		
	def _resize(self, cap):
		old = self._data
		self._data = [None] * cap
		walk = self._front
		for k in range(self._size):
			self._data[k] = old[walk]
			walk = (1 + walk) % len(old)
		self._front = 0

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

# 2022.5.4 Wed
# Tree_lab

class Node:
	def __init__(self, item=None, left=None, right=None):
		self.item, self.left, self.right = item, left, right

def preorder(root):
	if root is not None:
		print(root.item, end=" ")
		preorder(root.left)
		preorder(root.right)

def inorder(root):
	if root is not None:
		inorder(root.left)
		print(root.item, end=" ")
		inorder(root.right)

def postorder(root):
	if root is not None:
		postorder(root.left)
		postorder(root.right)
		print(root.item, end=" ")

def search(root, x):#preorder방식
	if root is None:
		return None
	if root.item == x:
		return root
	node = None
	
	if root.left: node = search(root.left, x)
	if node is not None: return node
	if root.right: node = search(root.right, x)
	return node

def insert_simple(p, side, x):
	global root
	if root is None:
		root = Node(x)
	else:
		node_p = search(root, p)
		if node_p is None: 
			return None
		if side=='left':
			node_p.left = Node(x)
		else:
			node_p.right = Node(x)

def size(root):
	if root is None: 
		return 0
	return 1+size(root.left)+size(root.right)
	
def height(root):
	if root is None:
		return -1
	return 1 + max(height(root.left), height(root.right))

root = None

while True:
	cmd = input()
	if cmd=='exit':
		break
	elif cmd=='preorder':
		preorder(root); print();
	elif cmd=='postorder':
		postorder(root); print();
	elif cmd=='inorder':
		inorder(root); print();
	elif cmd=='size':
		print(size(root))
	elif cmd=='height':
		print(height(root))
	else:
		cmd = cmd.split()
		if cmd[0]=='search':
			val = cmd[1]
			node = search(root, int(val))
			if node is None: print(val+' not found')
			else: print(val+' found') 
		elif cmd[0]=='insert':
			p, side, val = cmd[1:]
			insert_simple(int(p), side, int(val))
			
""" Node Class: storing (key, value) """
class Node:
	def __init__(self, key=None, value=None, left=None, right=None):
		self.item = (key, value)
		self.left, self.right = left, right
	
	def key(self):
		return self.item[0]
	
	def value(self):
		return self.item[1]
	
	def set_value(self, value):
		self.item[1] = value

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

# 2022.5.11 Wed
# Binary search tree

""" Binary Search Tree Class """
class BinarySearchTree:
	def __init__(self, root=None):
		self.root = root
	
	def search(self, key): # loop version
		root = self.root
		while root is not None:
			if key == root.key():
				break
			elif key < root.key():
				root = root.left
			elif key > root.key():
				root = root.right
		
		return root
	
	""" returns node holding key and its parent"""
	def search_p(self, key): 
		root, parent = self.root, None
		while root is not None: #root가 None이면 더이상 탐색할 노드가 없다.
			if key == root.key(): #key에 해당하는 node를 찾음
				break
			elif key < root.key(): #왼쪽 서브트리로 이동
				parent = root
				root = root.left
			elif key > root.key(): #오른쪽 서브트리로 이동
				parent = root
				root = root.right
		return root, parent
	
	def insert(self, key, value=None):
		node, p = self.search_p(key)
		if node is not None and k==node.key():
			node.set_value(value)
			return node
		
		new_node = Node(key, value)
		if p is None:
			self.root = new_node
		elif key < p.key():
			p.left = new_node
		else:
			p.right = new_node
		
		return node
	
	""" replace <node> with <rep_node> """ 
	# p: parent of <node>
	# rep_p: parent of <rep_node>
	def replace(self, node, rep_node, p, rep_p): 
		
		# A. REPLACE p-to-node link
		# case-1: node is root (p is None)
		# case-2: node is p.left
		# case-3: node is p.right
		if p is None: 
			self.root = rep_node
		elif node == p.left : 
			p.left = rep_node
		else: 
			p.right = rep_node
		
		# B. REPLACE node-to-child(s) link(s) IF <rep_node> exists
		# case-1: <rep_node> is <node>'s left child  --> Do nothing
		# case-2: <rep_node> is <node>'s right child --> replace the left link IF node.left exists
		# case-3: <rep_node> is not <node>'s child --> replace both left and right links
		if node.left is None and node.right is None:
			rep_node = None #B단계는 자식노드가 둘일때만 실행 - 삭제할 노드의 자식노드가 없는 경우 rep_node = None
		if rep_node == node.left:
			pass
		elif rep_node == node.right and node.left is not None:
			rep_node.left = node.left
		elif node is not rep_p:
			rep_node.left = node.left
			rep_node.right = node.right
		
		# C. DELETE <rep_p> to <rep_node> link (already coded below)
		rep_p.left = None
			
	def find_min_p(self, root, p):
		while root.left is not None:
			p = root
			root = root.left
		return root, p
		
	def delete(self, key):
		node, p = self.search_p(key)
		if node is None:
			return node
		
		# number of children <= 1
		elif node.left is None or node.right is None:
			# determine the child (left or right?)
			child = node.left
			if node.right is not None: child = node.right
			# replace <node> with <child>
			self.replace(node, child, p, node)
		
		# number of children == 2
		else:
			# find minimum key from the right subtree
			right_min, right_min_p = self.find_min_p(node.right, node)
			# replace <node> with <right_min>
			self.replace(node, right_min, p, right_min_p)
			
		return node
	
	def preorder(self, root):
		if root is not None:
			print(root.key(), end=" ")
			self.preorder(root.left)
			self.preorder(root.right)
	
	def postorder(self, root):
		if root is not None:
			self.postorder(root.left)
			self.postorder(root.right)
			print(root.key(), end=" ")
	
	def inorder(self, root):
		if root is not None:
			self.inorder(root.left)
			print(root.key(), end=" ")
			self.inorder(root.right)
	
				
