#2022.4.6
#Stack_01 : parantheses inspection
class Stack:
	def __init__(self):
		self.data = [] #initialize with anempty list
	def size(self):
		return len(self.data)
	def is_empty(self):
		return self.size() == 0 #True if empty, False otherwise
	def push(self, element):
		self.data.append(element)
	def pop(self):
		if self.is_empty():
			return "error"
		return self.data.pop()
	def top(self):
		if self.is_empty():
			return "error"
		return self.data[-1] # -1 : the last one
	
T = int(input())
for tc in range(1, T+1):
		sentence = input()
		l = len(sentence)
		lst = []
		for s in sentence:#( 이나 {이면 lst에 담음
			if s=='(' or s=='{':
				lst.append(s)#) 이나 }이 나오면 (나 { 전에 나왔는지 확인
			elif s==')' or s=='}':
				if len(lst)==0:
					False
					#적절하게 짝이 이루어졌는지 확인
					elif s==')' and lst.pop() =='{':
						False
					elif s=='}' and lst.pop() =='(':
						False
						#괄호가 모두 짝이 맞게 닫혔는지 확인
						if len(lst):
							result=0

		print('#{} {}'.format(tc, result))
	
	

#Stack_02 : infix-to-postfix
class Stack:
	def __init__(self):
		self.data = [] #initialize with anempty list	
	def size(self):
		return len(self.data)
	def is_empty(self):
		return self.size() == 0 #True if empty, False otherwise
	def push(self, element):
		self.data.append(element)
	def pop(self):
		if self.is_empty():
			return "error"
		return self.data.pop()
	def top(self):
		if self.is_empty():
			return "error"
		return self.data[-1] # -1 : the last one
	
#Infix-to-postfix #초기화
infix = input()
postfix = []
s = Stack()
	
precedence = {'+': 0, '-' : 0, '/' : 1, "*" : 1, '(' : 2}
	
for ch in infix : 
	#case 1: ch is operator or left bracket
	if ch in '+-/*(' : 
		while not s.is_empty() and precedence[ch] <= precedence[s.top()]:
			if s.top() == '(' :
				break
			op = s.pop()
			postfix.append(op)
		s.push(ch)
	elif ch == ')':# case2: reight bracket
		#pop until left bracket
		while not s.is_empty() and s.top() != '(':
			op = s.pop()
			postfix.append(op)
		s.pop() #pop the left bracket '('
		
	else: #operand
		#directly output to postfix
		postfix.append(ch)
		
while not s.is_empty():
				op = s.pop()
				postfix.append(op)
		
postfix = "".join(postfix)
print(postfix)
	
	
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/


#2022.4.19 
#Linkedlist_lab
class Node:
	def __init__(self, item=None, link=None):
		self.item, self.link = item, link

class LinkedList:
		def __init__(self):	
			self.head = None
		def print_list(self):
			node = self.head
			print('h->', end="")
			while node is not None:
				print("{}->".format(node.item), end="")
				node = node.link
			print(None)
		def insert_node(self, p, new_node):
			if self.head is None:
				self.head = new_node
			elif p is None:
				new_node.link = self.head
				self.head = new_node
			else:
				new_node.link = p.link
				p.link = new_node
		def delete_node(self, p, removed):
			if removed == self.head:
				self.head = removed.link
			else:
				p.link = removed.link
			del removed
		def insert_first(self, item): # insert before head
			new_node = Node(item)
			self.insert_node(p=None, new_node=new_node) #이전 노드가 없어서 p는 None
		def insert_last(self, item): # insert after tail
			new_node = Node(item) # 새 노드를 가져옴
			p = self.head # 마지막 노드이기 때문에 p값이 있음
			while p is not None and p.link is not None: #p.link가 none이면 p가 tail
				p = p.link
			self.insert_node(p=p, new_node = new_node)#	
		def search(self, item): # returns the node holding item
			node = self.head
			while node is not None:
				if node.item == item:
					return node
				node = node.link
			return None
		def search_prev(self, item): # returns the node holding item and the previous node
			p = None
			node = self.head
			while node is not None:
				if node.item == item :
					return node, p
				p = node
				node = node.link
			return None, p	
		def delete(self, item):
			removed ,p= self.search_prev(item) #search_prev으로 node찾기
			if removed is None: # removed는 삭제하려는 값임, 만약 이 값이 없다면
				print("Item not found")
				return
			self.delete_node(p=p, removed = removed) #delete_node로 삭제
		def reverse(self):
			p = None
			node = self.head
			while node is not None:
				new_node = node.link
				node.link = p
				p = node
				node = new_node
			self.head = p	

L = LinkedList()
while True:
	cmd = input()
	if cmd == "exit":
		break
	elif cmd == "print":
		L.print_list()
	elif cmd == "reverse":
			L.reverse()
	else:
		cmd, param = cmd.split() #cmd를 콜하기 위한 코드
		if cmd == "ins_first":
			L.insert_first(int(param))
		elif cmd == "ins_last":
			L.insert_last(int(param))
		elif cmd == "find":
			node = L.search(int(param))
			if node is None: print('Item Not Found')
			else: print("{} Found".format(node.item))
		elif cmd == "del":
			L.delete(int(param))
		

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

# 2022.4.21 Thu
# circular queue
class queue:
	DEFAULT_CAPACITY = 0
	
	def __init__(self):
		self._data = [None] * queue.DEFAULT_CAPACITY
		self._size = 0
		self._front = 0
		
	def __len__(self):
		return self._size
	
	def is_empty(self):
		return self._size == 0
	
	def first(self):
		if self.is_empty():
			raise Empty('Queue is empty')
		return self._data[self._front]
	
	def dequeue(self):
		if self.is_empty():
			raise Empty('Queue is empty')
		answer = self._data[self._front]
		self._data[self._front] = None
		self._front = (self._front + 1)% len(self._data)
		self._size -= 1
		return answer
	
	def enqueue(self, e):
		if self._size == len(self._data):
			self._resize(2*len(self.data))
		avail = (self._front + self._size) % len(self._data)
		self._data[avail] = e 
		self._size += 1
		
	def _resize(self, cap):
		old = self._data
		self._data = [None] * cap
		walk = self._front
		for k in range(self._size):
			self._data[k] = old[walk]
			walk = (1 + walk) % len(old)
		self._front = 0

/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/

# 2022.5.4 Wed
# Tree_lab

class Node:
	def __init__(self, item=None, left=None, right=None):
		self.item, self.left, self.right = item, left, right

def preorder(root):
	if root is not None:
		print(root.item, end=" ")
		preorder(root.left)
		preorder(root.right)

def inorder(root):
	if root is not None:
		inorder(root.left)
		print(root.item, end=" ")
		inorder(root.right)

def postorder(root):
	if root is not None:
		postorder(root.left)
		postorder(root.right)
		print(root.item, end=" ")

def search(root, x):#preorder방식
	if root is None:
		return None
	if root.item == x:
		return root
	node = None
	
	if root.left: node = search(root.left, x)
	if node is not None: return node
	if root.right: node = search(root.right, x)
	return node

def insert_simple(p, side, x):
	global root
	if root is None:
		root = Node(x)
	else:
		node_p = search(root, p)
		if node_p is None: 
			return None
		if side=='left':
			node_p.left = Node(x)
		else:
			node_p.right = Node(x)

def size(root):
	if root is None: 
		return 0
	return 1+size(root.left)+size(root.right)
	
def height(root):
	if root is None:
		return -1
	return 1 + max(height(root.left), height(root.right))

root = None

while True:
	cmd = input()
	if cmd=='exit':
		break
	elif cmd=='preorder':
		preorder(root); print();
	elif cmd=='postorder':
		postorder(root); print();
	elif cmd=='inorder':
		inorder(root); print();
	elif cmd=='size':
		print(size(root))
	elif cmd=='height':
		print(height(root))
	else:
		cmd = cmd.split()
		if cmd[0]=='search':
			val = cmd[1]
			node = search(root, int(val))
			if node is None: print(val+' not found')
			else: print(val+' found') 
		elif cmd[0]=='insert':
			p, side, val = cmd[1:]
			insert_simple(int(p), side, int(val))
